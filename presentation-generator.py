import os
import json
import pickle
import time
import logging
import uuid # Keep for potential future use

# Gemini SDK Imports (New SDK)
from google import genai
from google.genai import types

# Google Slides API Imports
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# --- Configuration ---
SCOPES = ['https://www.googleapis.com/auth/presentations']
CREDENTIALS_FILE = 'credentials.json'
TOKEN_PICKLE_FILE = 'token.pickle'

# --- IMPORTANT: SET YOUR API KEY HERE ---
GEMINI_API_KEY = "your-api-key-here"
# -----------------------------------------

INPUT_TOPIC_FILE = 'topic.txt'
PRESENTATION_TITLE_PREFIX = "AI Generated: "

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Google Slides Authentication ---
def get_google_slides_credentials():
    creds = None
    if os.path.exists(TOKEN_PICKLE_FILE):
        with open(TOKEN_PICKLE_FILE, 'rb') as token:
            creds = pickle.load(token)
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except Exception as e:
                logging.warning(f"Could not refresh Google token: {e}. Need to re-authenticate.")
                if os.path.exists(TOKEN_PICKLE_FILE):
                    os.remove(TOKEN_PICKLE_FILE)
                flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
                creds = flow.run_local_server(port=0)
        else:
            flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
            creds = flow.run_local_server(port=0)
        with open(TOKEN_PICKLE_FILE, 'wb') as token:
            pickle.dump(creds, token)
    logging.info("Google Slides credentials obtained.")
    return creds

# --- Gemini Content Generation (Text Only) ---
def generate_slide_content(topic, gemini_client, model_name="gemini-2.0-flash"):
    logging.info(f"Generating professional slide content for topic: '{topic}' using {model_name}...")
    prompt = f"""
    Create a comprehensive professional presentation outline suitable for Google Slides on the topic: "{topic}".
    
    Generate content for 8-10 detailed slides (including a title slide and a concluding slide).
    For each slide, provide ONLY the following in a strictly structured format:
    1.  `title`: A clear, concise, and professional title for the slide (5-7 words maximum).
    2.  `body`: Professional, structured, and well-explained content with:
        - Use bullet points with '\\n ' prefix
        - Format each bullet point as 'Key Term: explanation'
        - Keep each bullet point focused and exhaustive (1-2 sentences min, 5-6 sentences max)
        - Use clear hierarchical organization of information
        - Include specific facts or examples but keep them brief
        - Limit to 3-5 key points per slide
    
    Output the result *only* as a valid JSON list of objects, where each object represents a slide. Example format:
    [
      {{
        "title": "Key Benefits Overview",
        "body": "- Increased Efficiency: 35% productivity improvement.\\n- Cost Reduction: Saves $10,000 annually.\\n- Better User Experience: 98% customer satisfaction."
      }},
      // ... more slides
    ]
    Ensure content is schematic, understandable, and visually scannable for presentation audiences.
    """
    safety_settings_list = [
        types.SafetySetting(category='HARM_CATEGORY_HATE_SPEECH', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_DANGEROUS_CONTENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_HARASSMENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
    ]
    try:
        response = gemini_client.models.generate_content(
            model=model_name, contents=prompt,
            config=types.GenerateContentConfig(
                temperature=0.6, response_mime_type="application/json",
                safety_settings=safety_settings_list))

        if not response.candidates:
             logging.error("Gemini returned no candidates.")
             return None

        json_text = response.text
        slide_data = json.loads(json_text)
        logging.info(f"Successfully generated professional content for {len(slide_data)} slides.")

        logging.info("--- Content generated by Gemini ---")
        try:
            logging.info(json.dumps(slide_data, indent=2))
        except Exception as json_e:
             logging.error(f"Could not pretty-print slide data: {json_e}")
             logging.info(str(slide_data))
        logging.info("---------------------------------")

        return slide_data

    except json.JSONDecodeError as e:
        logging.error(f"Error: Failed to decode JSON response from Gemini: {e}")
        return None
    except Exception as e:
        logging.error(f"Error during Gemini content generation: {e}", exc_info=True)
        return None


# --- Helper function to find specific placeholder IDs on a slide ---
def find_placeholder_ids(page):
    ids = {'TITLE': None, 'BODY': None, 'SUBTITLE': None}
    if not page or 'pageElements' not in page: return ids
    for element in page.get('pageElements', []):
        placeholder = element.get('shape', {}).get('placeholder')
        if placeholder:
            p_type = placeholder.get('type')
            if p_type in ids: ids[p_type] = element.get('objectId')
    return ids

# --- Google Slides Creation (Robust Placeholder Targeting, Insert Only, SyntaxError FIXED) ---
def create_presentation_from_data(slide_data, presentation_title, slides_service):
    logging.info(f"Creating presentation: '{presentation_title}' (Robust Placeholder Targeting)...")

    presentation_id = None; presentation_url = None
    try:
        presentation = slides_service.presentations().create(body={'title': presentation_title}).execute()
        presentation_id = presentation.get('presentationId')
        if not presentation_id: raise ValueError("Failed to retrieve presentationId after creation.")
        presentation_url = f"https://docs.google.com/presentation/d/{presentation_id}/edit"
        logging.info(f"Created presentation shell with ID: {presentation_id}")
        logging.info(f"Link: {presentation_url}")
    except HttpError as error:
        logging.error(f"Failed to create presentation shell: {error}")
        error_content = "N/A"
        try:
            if hasattr(error, 'content') and error.content:
                error_content = error.content.decode('utf-8')
        except Exception:
            error_content = str(error.content)
        logging.error(f"Details: Status={error.resp.status}, Content={error_content}")
        return None, None
    except Exception as e:
        logging.error(f"Unexpected error creating presentation shell: {e}", exc_info=True)
        return None, None

    # Create all slides from scratch instead of using the default one
    create_slide_requests = [{'createSlide': {'slideLayoutReference': {'predefinedLayout': 'TITLE_AND_BODY'}}} for _ in range(len(slide_data))]
    logging.info(f"Sending batch request to create {len(create_slide_requests)} new slide(s)...")
    
    newly_created_slide_ids = []
    try:
        response = slides_service.presentations().batchUpdate(presentationId=presentation_id, body={'requests': create_slide_requests}).execute()
        replies = response.get('replies', [])
        if len(replies) == len(create_slide_requests):
            for reply in replies:
                new_id = reply.get('createSlide', {}).get('objectId')
                if new_id: newly_created_slide_ids.append(new_id)
                else: logging.warning("A createSlide reply was missing an objectId.")
            logging.info(f"Successfully created {len(newly_created_slide_ids)} new slide(s).")
        else: logging.warning(f"Create requests/replies mismatch: {len(create_slide_requests)}/{len(replies)}.")
    except HttpError as error:
        logging.error(f"\n!!! FAILED during Phase 1 (Create Slides): {error}")
        error_content = "N/A"
        try:
            if hasattr(error, 'content') and error.content:
                error_content = error.content.decode('utf-8')
        except Exception:
            error_content = str(error.content)
        logging.error(f"  Details: Status={error.resp.status}, Content={error_content}")
        return presentation_id, f"{presentation_url} (Errors occurred during slide creation)"

    # Delete the default first slide that was created with the presentation
    try:
        logging.info("Fetching presentation details to identify default slide...")
        time.sleep(1.0)
        presentation = slides_service.presentations().get(presentationId=presentation_id).execute()
        default_slides = presentation.get('slides', [])
        
        if default_slides:
            # Find the default slide that was created with the presentation
            default_slide_ids = [slide.get('objectId') for slide in default_slides 
                                if slide.get('objectId') not in newly_created_slide_ids]
            
            if default_slide_ids:
                delete_requests = [{'deleteObject': {'objectId': slide_id}} for slide_id in default_slide_ids]
                logging.info(f"Deleting {len(delete_requests)} default slide(s)...")
                slides_service.presentations().batchUpdate(
                    presentationId=presentation_id, 
                    body={'requests': delete_requests}
                ).execute()
                logging.info("Successfully deleted default slide(s).")
    except Exception as e:
        logging.error(f"Error during default slide deletion: {e}", exc_info=True)
        # Continue with the rest of the process even if this fails

    all_slide_ids = []
    try:
        logging.info("Fetching updated presentation details with placeholders...")
        time.sleep(2.0)
        fields_to_get = "slides(objectId,pageElements(objectId,shape(placeholder(type))))"
        presentation = slides_service.presentations().get(presentationId=presentation_id, fields=fields_to_get).execute()
        if not presentation.get('slides'): raise ValueError("Presentation has no slides after creation phase.")

        all_slides_info = {}
        for page in presentation.get('slides', []):
            slide_id = page.get('objectId')
            if slide_id:
                all_slides_info[slide_id] = find_placeholder_ids(page)
                all_slide_ids.append(slide_id)

        logging.info(f"Found placeholder info for {len(all_slides_info)} slides.")
        logging.info(f"Total slides to process: {len(all_slide_ids)}. IDs: {all_slide_ids}")
        if len(all_slide_ids) != len(slide_data): logging.warning(f"Slide info/data count mismatch: {len(all_slide_ids)}/{len(slide_data)}.")

    except Exception as e:
        logging.error(f"Failed to get slide placeholder IDs: {e}", exc_info=True)
        return presentation_id, f"{presentation_url} (Error getting placeholder IDs)"

    logging.info("Starting Phase 3: Modifying slides individually using placeholder IDs...")
    any_slide_update_failed = False

    for i, current_slide_id in enumerate(all_slide_ids):
        if current_slide_id not in all_slides_info: logging.warning(f"Skipping ID {current_slide_id}: missing placeholder info."); continue
        if i >= len(slide_data): logging.warning(f"Skipping ID {current_slide_id}: data count mismatch."); continue

        placeholder_ids = all_slides_info[current_slide_id]
        slide_content = slide_data[i]
        modify_requests = []
        slide_title = slide_content.get('title', f'Slide {i+1}')
        slide_body = slide_content.get('body', '')

        logging.info(f"Processing modifications for slide {i+1} (ID: {current_slide_id})...")

        title_object_id = placeholder_ids.get('TITLE')
        body_object_id = placeholder_ids.get('BODY')
        subtitle_object_id = placeholder_ids.get('SUBTITLE')

        # Insert Title Text (without prior delete)
        if title_object_id and slide_title:
            modify_requests.append({'insertText': {'objectId': title_object_id, 'insertionIndex': 0, 'text': slide_title}})
            logging.info(f"  - Added insertText request for TITLE placeholder: {title_object_id}")
        elif not title_object_id:
            logging.warning(f"  - TITLE placeholder ID not found for slide {i+1}. Cannot insert title.")
        else:
            logging.info(f"  - No title content provided by Gemini for slide {i+1}.")

        # Insert Body Text (using the appropriate placeholder for the slide)
        target_body_object_id = subtitle_object_id if i == 0 else body_object_id
        placeholder_name_for_log = "SUBTITLE" if i == 0 else "BODY"

        if target_body_object_id and slide_body:
            modify_requests.append({'insertText': {'objectId': target_body_object_id, 'insertionIndex': 0, 'text': slide_body}})
            logging.info(f"  - Added insertText request for {placeholder_name_for_log} placeholder: {target_body_object_id}")
        elif not target_body_object_id and slide_body:
            logging.warning(f"  - {placeholder_name_for_log} placeholder ID not found for slide {i+1}, cannot insert body text.")
        else:
            logging.info(f"  - No body text provided or {placeholder_name_for_log} placeholder not found for slide {i+1}.")

        # Add a text box adjustment for title slides or slides with long titles to prevent overlap
        if i == 0 or len(slide_title) > 40:  # Adjust threshold as needed
            if target_body_object_id:
                # Adjust text position down to avoid overlap with long titles
                modify_requests.append({
                    'updateParagraphStyle': {
                        'objectId': target_body_object_id,
                        'style': {
                            'spaceAbove': {
                                'magnitude': 40,  # Add space above the text
                                'unit': 'PT'
                            }
                        },
                        'fields': 'spaceAbove',
                        'textRange': {'type': 'ALL'}
                    }
                })
                logging.info(f"  - Added position adjustment for text in slide {i+1} to prevent overlap with title.")

        if modify_requests:
            logging.info(f"  - Sending {len(modify_requests)} modification updates for slide {i+1}...")
            body = {'requests': modify_requests}
            try:
                if i == 0: time.sleep(1.5)  # Longer delay before first slide modification attempt
                else: time.sleep(0.8)

                slides_service.presentations().batchUpdate(presentationId=presentation_id, body=body).execute()
                logging.info(f"  - Successfully modified slide {i+1}.")
            except HttpError as error:
                any_slide_update_failed = True
                logging.error(f"\n!!! FAILED to modify slide {i+1} (ID: {current_slide_id}): {error}")
                error_content = "N/A"
                try:
                    if hasattr(error, 'content') and error.content:
                        error_content = error.content.decode('utf-8')
                except Exception:
                    error_content = str(error.content)
                logging.error(f"  - Details: Status={error.resp.status}, Content={error_content}")
                try:
                    log_body = json.dumps(body, indent=2);
                    if len(log_body) > 2000: log_body = log_body[:2000] + "\n... (body truncated)"
                    logging.debug(f"  - Failed Request Body for slide {i+1}:\n{log_body}")
                except Exception as log_e: logging.debug(f"  - Could not serialize failed request body: {log_e}")
        else:
            logging.warning(f"  - No modification requests generated for slide {i+1}.")

    final_url = presentation_url
    if any_slide_update_failed:
        if presentation_url and "(Errors occurred" not in presentation_url and "(Error processing" not in presentation_url and "(Error getting" not in presentation_url:
            final_url += " (Errors occurred during slide modifications)"
        elif presentation_url: final_url += " + modification errors"

    return presentation_id, final_url

def add_shapes_with_text_to_slides(presentation_id, slides_service, topic, gemini_client):
    """Add decorative shapes with text to slides"""
    logging.info(f"Adding shapes with text to slides for topic: '{topic}'")
    
    try:
        # Get all slides from the presentation
        presentation = slides_service.presentations().get(presentationId=presentation_id).execute()
        slides = presentation.get('slides', [])
        
        if not slides:
            logging.warning("No slides found in presentation to add shapes to.")
            return False
        
        # Generate shape content using Gemini
        shape_content = generate_shape_content(topic, gemini_client)
        if not shape_content:
            logging.warning("Failed to generate shape content. Using default content.")
            # Default content if Gemini fails
            shape_content = [
                {"text": "Key Point", "color": {"red": 0.8, "green": 0.2, "blue": 0.2}},
                {"text": "Important Insight", "color": {"red": 0.2, "green": 0.6, "blue": 0.8}},
                {"text": "Remember This", "color": {"red": 0.2, "green": 0.7, "blue": 0.3}}
            ]
        
        # Add shapes to each content slide (skip title slide)
        for i, slide in enumerate(slides):
            if i == 0:  # Skip title slide
                continue
                
            slide_id = slide.get('objectId')
            if not slide_id:
                continue
            
            # Place a shape in the bottom right corner of each content slide
            shape_idx = (i - 1) % len(shape_content)
            shape_data = shape_content[shape_idx]
            
            # Create a unique ID for this shape
            shape_id = f"decorativeShape_{slide_id}_{i}"
            
            # Convert RGB values to proper format
            rgb_color = {
                "rgbColor": {
                    "red": shape_data["color"]["red"],
                    "green": shape_data["color"]["green"],
                    "blue": shape_data["color"]["blue"]
                }
            }
            
            # Create shape creation request
            requests = [
                {
                    "createShape": {
                        "objectId": shape_id,
                        "shapeType": "ROUND_RECTANGLE",  # Correct value from API
                        "elementProperties": {
                            "pageObjectId": slide_id,
                            "size": {
                                "height": {"magnitude": 80, "unit": "PT"},
                                "width": {"magnitude": 200, "unit": "PT"}
                            },
                            "transform": {
                                "scaleX": 1,
                                "scaleY": 1,
                                "translateX": 400,  # Position in bottom right
                                "translateY": 350,
                                "unit": "PT"
                            }
                        }
                    }
                },
                # Insert text into the shape
                {
                    "insertText": {
                        "objectId": shape_id,
                        "insertionIndex": 0,
                        "text": shape_data["text"]
                    }
                },
                # Style the shape
                {
                    "updateShapeProperties": {
                        "objectId": shape_id,
                        "fields": "shapeBackgroundFill.solidFill.color",
                        "shapeProperties": {
                            "shapeBackgroundFill": {
                                "solidFill": {
                                    "color": rgb_color
                                }
                            }
                        }
                    }
                },
                # Style the text in the shape
                {
                    "updateTextStyle": {
                        "objectId": shape_id,
                        "textRange": {"type": "ALL"},
                        "fields": "foregroundColor,bold,fontFamily,fontSize",
                        "style": {
                            "foregroundColor": {
                                "opaqueColor": {
                                    "rgbColor": {
                                        "red": 1.0,
                                        "green": 1.0,
                                        "blue": 1.0
                                    }
                                }
                            },
                            "bold": True,
                            "fontFamily": "Arial",
                            "fontSize": {"magnitude": 14, "unit": "PT"}
                        }
                    }
                },
                # Center align the text
                {
                    "updateParagraphStyle": {
                        "objectId": shape_id,
                        "textRange": {"type": "ALL"},
                        "fields": "alignment",
                        "style": {
                            "alignment": "CENTER"
                        }
                    }
                }
            ]
            
            # Execute the request
            body = {"requests": requests}
            try:
                slides_service.presentations().batchUpdate(
                    presentationId=presentation_id, body=body
                ).execute()
                logging.info(f"Added shape with text to slide {i+1}")
                time.sleep(0.5)  # Prevent rate limiting
            except Exception as slide_error:
                logging.error(f"Error adding shape to slide {i+1}: {slide_error}")
            
        return True
        
    except Exception as e:
        logging.error(f"Error adding shapes to slides: {e}", exc_info=True)
        return False

def generate_shape_content(topic, gemini_client, model_name="gemini-2.0-flash"):
    """Generate content for decorative shapes based on the topic"""
    logging.info(f"Generating shape content for topic: '{topic}' using {model_name}...")
    
    prompt = f"""
    Create 5 short, impactful phrases (3-5 words each) related to the topic "{topic}" that would 
    be appropriate to highlight in decorative shapes on a presentation. 
    
    Each phrase should:
    - Emphasize a key point about {topic}
    - Be concise and memorable
    - Be suitable for a professional presentation
    
    Also include a suggested color for each shape (in RGB format).
    
    Output ONLY as JSON array with this structure:
    [
      {{"text": "Phrase 1", "color": {{"red": 0.2, "green": 0.6, "blue": 0.8}}}},
      {{"text": "Phrase 2", "color": {{"red": 0.7, "green": 0.3, "blue": 0.5}}}}
    ]
    """
    
    safety_settings_list = [
        types.SafetySetting(category='HARM_CATEGORY_HATE_SPEECH', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_DANGEROUS_CONTENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_HARASSMENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
    ]
    
    try:
        response = gemini_client.models.generate_content(
            model=model_name, contents=prompt,
            config=types.GenerateContentConfig(
                temperature=0.4, response_mime_type="application/json",
                safety_settings=safety_settings_list))
        
        if not response.candidates:
            logging.error("Gemini returned no shape content candidates.")
            return None
            
        json_text = response.text
        shape_data = json.loads(json_text)
        logging.info(f"Successfully generated content for {len(shape_data)} shapes.")
        
        return shape_data
        
    except Exception as e:
        logging.error(f"Error during shape content generation: {e}", exc_info=True)
        return None

def generate_slide_styling_instructions(topic, gemini_client, model_name="gemini-2.0-flash"):
    """Generate styling instructions for a presentation based on the topic"""
    logging.info(f"Generating styling instructions for topic: '{topic}' using {model_name}...")
    
    prompt = """
    Create professional styling instructions for a Google Slides presentation on the topic: "{0}".
        
    For each slide type, provide specific text styling recommendations:
    
    1. Title slide: Use a clean, modern font with moderate size (28-32pt for title, 18-22pt for subtitle)
    2. Content slides: Use slightly smaller fonts (24-26pt for titles, 16-18pt for bullet points)
    3. Color scheme: A professional 3-4 color palette with sufficient contrast for readability
    
    Output ONLY valid JSON with this structure:
    {{
      "title_slide": {{
        "title": {{
          "fontFamily": "Font name",
          "fontSize": 30,
          "fontColor": {{"red": 0.2, "green": 0.4, "blue": 0.8}},
          "bold": true,
          "italic": false
        }},
        "subtitle": {{
          "fontFamily": "Font name",
          "fontSize": 20,
          "fontColor": {{"red": 0.3, "green": 0.5, "blue": 0.7}},
          "bold": false,
          "italic": true
        }}
      }},
      "content_slides": {{
        "title": {{
          "fontFamily": "Font name",
          "fontSize": 24,
          "fontColor": {{"red": 0.2, "green": 0.4, "blue": 0.8}},
          "bold": true,
          "italic": false
        }},
        "body": {{
          "fontFamily": "Font name",
          "fontSize": 16,
          "fontColor": {{"red": 0.2, "green": 0.2, "blue": 0.2}},
          "bulletStyle": "BULLET_ARROW",
          "bold": false,
          "italic": false
        }}
      }},
      "color_scheme": [
        {{"name": "Primary", "hex": "#3a86ff", "rgb": {{"red": 0.23, "green": 0.53, "blue": 1.0}}}},
        {{"name": "Secondary", "hex": "#8338ec", "rgb": {{"red": 0.51, "green": 0.22, "blue": 0.93}}}},
        {{"name": "Accent", "hex": "#ff006e", "rgb": {{"red": 1.0, "green": 0.0, "blue": 0.43}}}},
        {{"name": "Text", "hex": "#212529", "rgb": {{"red": 0.13, "green": 0.15, "blue": 0.16}}}}
      ]
    }}
        
    Choose fonts from this list: Arial, Roboto, Verdana, Georgia, Montserrat, Lato, Open Sans.
        

    For bulletStyle, use one of these values: BULLET_ARROW, BULLET_CIRCLE, BULLET_SQUARE, BULLET_DIAMOND, BULLET_CHECKBOX, NUMBERED, NUMBERED_PARENS, NUMBERED_NESTED, or BULLET_NONE.
    
    Select a color scheme that thematically connects to the topic's essence.
    Remember that less is more in presentations - keep styling clean and focus on readability.

    """.format(topic)
    
    
    safety_settings_list = [
        types.SafetySetting(category='HARM_CATEGORY_HATE_SPEECH', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_DANGEROUS_CONTENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_HARASSMENT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
        types.SafetySetting(category='HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold='BLOCK_MEDIUM_AND_ABOVE'),
    ]
    
    try:
        response = gemini_client.models.generate_content(
            model=model_name, contents=prompt,
            config=types.GenerateContentConfig(
                temperature=0.4, response_mime_type="application/json",
                safety_settings=safety_settings_list))
        
        if not response.candidates:
            logging.error("Gemini returned no styling candidates.")
            return None
            
        json_text = response.text
        styling_data = json.loads(json_text)
        logging.info(f"Successfully generated styling instructions.")
        
        return styling_data
        
    except json.JSONDecodeError as e:
        logging.error(f"Error: Failed to decode JSON styling response from Gemini: {e}")
        return None
    except Exception as e:
        logging.error(f"Error during Gemini styling generation: {e}", exc_info=True)
        return None

def optimize_text_layout(presentation_id, slides_service):
    """Optimize text spacing and positioning on slides"""
    logging.info(f"Optimizing text layout in presentation: {presentation_id}")
    
    try:
        # Get all slides from the presentation
        presentation = slides_service.presentations().get(presentationId=presentation_id).execute()
        slides = presentation.get('slides', [])
        
        if not slides:
            logging.warning("No slides found in presentation to optimize.")
            return False
            
        for i, slide in enumerate(slides):
            slide_id = slide.get('objectId')
            if not slide_id:
                continue
                
            # Get placeholder IDs
            placeholder_ids = find_placeholder_ids(slide)
            layout_requests = []
            
            # Adjust body text positioning and spacing
            body_id = placeholder_ids.get('BODY')
            if body_id:
                # Add more space between bullet points
                layout_requests.append({
                    'updateParagraphStyle': {
                        'objectId': body_id,
                        'style': {
                            'lineSpacing': 115,  # Slightly increased line spacing
                            'spaceBelow': {
                                'magnitude': 10,
                                'unit': 'PT'
                            }
                        },
                        'fields': 'lineSpacing,spaceBelow',
                        'textRange': {'type': 'ALL'}
                    }
                })
            
            # Execute layout optimization for this slide
            if layout_requests:
                body = {'requests': layout_requests}
                try:
                    slides_service.presentations().batchUpdate(
                        presentationId=presentation_id, body=body
                    ).execute()
                    logging.info(f"Optimized text layout on slide {i+1}")
                    time.sleep(0.5)
                except Exception as e:
                    logging.error(f"Failed to optimize layout on slide {i+1}: {e}")
        
        return True
    except Exception as e:
        logging.error(f"Error optimizing text layout: {e}", exc_info=True)
        return False

def create_paragraph_bullets_request(object_id, bullet_preset):
    """Create a properly formatted bullet styling request"""
    # Valid bullet preset values from the Google Slides API documentation
    valid_bullet_presets = [
        "BULLET_ARROW_DIAMOND_DISC",
        "BULLET_ARROW_CIRCLE_SQUARE",
        "BULLET_ARROW_SQUARE_DIAMOND",
        "BULLET_DIAMOND_SQUARE_ARROW",
        "BULLET_CHECKBOX",
        "BULLET_NONE",
        "NUMBERED_DIGIT_ALPHA_ROMAN",
        "NUMBERED_DIGIT_ALPHA_ROMAN_PARENS",
        "NUMBERED_DIGIT_NESTED"
    ]
    
    # Default to a common bullet style if the requested style is invalid
    if bullet_preset not in valid_bullet_presets:
        bullet_preset = "BULLET_ARROW_DIAMOND_DISC"
    
    return {
        'createParagraphBullets': {
            'objectId': object_id,
            'textRange': {'type': 'ALL'},
            'bulletPreset': bullet_preset
        }
    }


def apply_presentation_styling(presentation_id, slides_service, slide_data, styling_data):
    """Apply the generated styling to all slides in the presentation"""
    logging.info(f"Applying styling to presentation: {presentation_id}")
    
    if not styling_data:
        logging.warning("No styling data provided. Using default styling.")
        return False
    
    try:
        # Get all slides from the presentation
        presentation = slides_service.presentations().get(presentationId=presentation_id).execute()
        slides = presentation.get('slides', [])
        
        if not slides:
            logging.warning("No slides found in presentation to style.")
            return False
            
        for i, slide in enumerate(slides):
            slide_id = slide.get('objectId')
            if not slide_id:
                logging.warning(f"Slide at index {i} has no objectId. Skipping styling.")
                continue
                
            # Fetch placeholder IDs for this slide
            placeholder_ids = find_placeholder_ids(slide)
            
            # Create style requests based on slide position
            style_requests = []
            
            # Apply styling for title slide (first slide)
            if i == 0 and styling_data.get('title_slide'):
                title_style = styling_data['title_slide'].get('title', {})
                subtitle_style = styling_data['title_slide'].get('subtitle', {})
                
                # Style the title if placeholder exists
                if placeholder_ids.get('TITLE') and title_style:
                    style_requests.append(create_text_style_request(
                        placeholder_ids['TITLE'], 
                        title_style
                    ))
                
                # Style the subtitle if placeholder exists
                if placeholder_ids.get('SUBTITLE') and subtitle_style:
                    style_requests.append(create_text_style_request(
                        placeholder_ids['SUBTITLE'], 
                        subtitle_style
                    ))
            
            # Apply styling for content slides
            elif i > 0 and styling_data.get('content_slides'):
                title_style = styling_data['content_slides'].get('title', {})
                body_style = styling_data['content_slides'].get('body', {})
                
                # Style the title if placeholder exists
                if placeholder_ids.get('TITLE') and title_style:
                    style_requests.append(create_text_style_request(
                        placeholder_ids['TITLE'], 
                        title_style
                    ))
                
                # Style the body if placeholder exists
                if placeholder_ids.get('BODY') and body_style:
                    style_requests.append(create_text_style_request(
                        placeholder_ids['BODY'], 
                        body_style
                    ))
                    
                    # Add bullet styling if specified
                    if body_style.get('bulletStyle'):
                        # Map string bullet styles to valid API bullet presets
                        bullet_style_mapping = {
                            "BULLET_DISC": "BULLET_ARROW_DIAMOND_DISC",
                            "BULLET_CIRCLE": "BULLET_ARROW_CIRCLE_SQUARE",
                            "BULLET_SQUARE": "BULLET_ARROW_SQUARE_DIAMOND",
                            "BULLET_DIAMOND": "BULLET_DIAMOND_SQUARE_ARROW",
                            "BULLET_ARROW": "BULLET_ARROW_DIAMOND_DISC",
                            "BULLET_CHECKBOX": "BULLET_CHECKBOX",
                            "BULLET_NONE": "BULLET_NONE",
                            "NUMBERED": "NUMBERED_DIGIT_ALPHA_ROMAN",
                            "NUMBERED_PARENS": "NUMBERED_DIGIT_ALPHA_ROMAN_PARENS",
                            "NUMBERED_NESTED": "NUMBERED_DIGIT_NESTED"
                        }
                        
                        bullet_preset = bullet_style_mapping.get(
                            body_style['bulletStyle'], 
                            "BULLET_ARROW_DIAMOND_DISC"  # Default fallback
                        )
                        
                        style_requests.append(create_paragraph_bullets_request(
                            placeholder_ids['BODY'], 
                            bullet_preset
                        ))
            
            # Apply the styling requests for this slide
            if style_requests:
                body = {'requests': style_requests}
                try:
                    slides_service.presentations().batchUpdate(
                        presentationId=presentation_id, 
                        body=body
                    ).execute()
                    logging.info(f"Applied styling to slide {i+1} (ID: {slide_id})")
                    time.sleep(0.5)  # Prevent rate limiting
                except Exception as e:
                    logging.error(f"Failed to apply styling to slide {i+1}: {e}")
        
        return True
    
    except Exception as e:
        logging.error(f"Error applying presentation styling: {e}", exc_info=True)
        return False


def create_text_style_request(object_id, style_info):
    """Create a text style update request based on style information"""
    style_fields = []
    text_style = {}
    
    # Map style attributes to Slides API format
    if 'fontFamily' in style_info:
        text_style['fontFamily'] = style_info['fontFamily']
        style_fields.append('fontFamily')
        
    if 'fontSize' in style_info:
        # Reduce font size by 15-20% from what was specified
        original_size = style_info['fontSize']
        adjusted_size = int(original_size * 0.85)  # Reduce by 15%
        text_style['fontSize'] = {'magnitude': adjusted_size, 'unit': 'PT'}
        style_fields.append('fontSize')
        
    if 'fontColor' in style_info:
        text_style['foregroundColor'] = {
            'opaqueColor': {
                'rgbColor': style_info['fontColor']
            }
        }
        style_fields.append('foregroundColor')
        
    if 'bold' in style_info:
        text_style['bold'] = style_info['bold']
        style_fields.append('bold')
        
    if 'italic' in style_info:
        text_style['italic'] = style_info['italic']
        style_fields.append('italic')
    
    # Return the complete update request
    return {
        'updateTextStyle': {
            'objectId': object_id,
            'textRange': {'type': 'ALL'},
            'style': text_style,
            'fields': ','.join(style_fields)
        }
    }

def apply_bold_to_bullet_prefixes(presentation_id, slides_service):
    """Format bullet points to make text before colons bold"""
    logging.info(f"Applying bold formatting to bullet point prefixes in presentation: {presentation_id}")
    
    try:
        # Get all slides from the presentation
        presentation = slides_service.presentations().get(presentationId=presentation_id).execute()
        slides = presentation.get('slides', [])
        
        if not slides:
            logging.warning("No slides found to format bullet prefixes.")
            return False
        
        for i, slide in enumerate(slides):
            if i == 0:  # Skip title slide
                continue
                
            slide_id = slide.get('objectId')
            if not slide_id:
                continue
                
            # Get placeholder IDs
            placeholder_ids = find_placeholder_ids(slide)
            body_id = placeholder_ids.get('BODY')
            
            if not body_id:
                continue
                
            # First, get the text content to analyze
            try:
                text_content = slides_service.presentations().get(
                    presentationId=presentation_id,
                    fields=f"slides(objectId,pageElements(objectId,shape(text)))"
                ).execute()
                
                # Find the text content for this specific body element
                text_runs = []
                for current_slide in text_content.get('slides', []):
                    if current_slide.get('objectId') != slide_id:
                        continue
                        
                    for element in current_slide.get('pageElements', []):
                        if element.get('objectId') == body_id and 'shape' in element:
                            if 'text' in element['shape'] and 'textElements' in element['shape']['text']:
                                for text_element in element['shape']['text']['textElements']:
                                    if 'textRun' in text_element and 'content' in text_element['textRun']:
                                        content = text_element['textRun']['content']
                                        start_index = text_element.get('startIndex', 0)
                                        end_index = start_index + len(content)
                                        text_runs.append((content, start_index, end_index))
                
                # Process each text run to find and bold text before colons
                formatting_requests = []
                
                for content, start_idx, _ in text_runs:
                    # Look for bullet points with colons
                    lines = content.split('\n')
                    for line in lines:
                        line = line.strip()
                        if line.startswith('- ') and ':' in line:
                            prefix_end = line.index(':') + 1  # Include the colon
                            line_start_idx = content.find(line) + start_idx
                            
                            # Create a request to bold the prefix
                            formatting_requests.append({
                                'updateTextStyle': {
                                    'objectId': body_id,
                                    'textRange': {
                                        'type': 'FIXED_RANGE',
                                        'startIndex': line_start_idx + 2,  # Skip the "- " part
                                        'endIndex': line_start_idx + prefix_end
                                    },
                                    'style': {
                                        'bold': True
                                    },
                                    'fields': 'bold'
                                }
                            })
                
                # Execute the formatting requests for this slide
                if formatting_requests:
                    body = {'requests': formatting_requests}
                    slides_service.presentations().batchUpdate(
                        presentationId=presentation_id, body=body
                    ).execute()
                    logging.info(f"Applied bold formatting to bullet prefixes on slide {i+1}")
                    time.sleep(0.5)  # Prevent rate limiting
            
            except Exception as text_error:
                logging.error(f"Error processing text on slide {i+1}: {text_error}")
        
        return True
    
    except Exception as e:
        logging.error(f"Error formatting bullet prefixes: {e}", exc_info=True)
        return False


def create_themed_presentation(topic, gemini_client, slides_service):
    """Create a fully styled presentation based on topic"""
    logging.info(f"Creating themed presentation for topic: '{topic}'")
    
    # Step 1: Generate slide content
    slide_data = generate_slide_content(topic, gemini_client)
    if not slide_data:
        logging.error("Failed to generate slide content")
        return None, None
    
    # Step 2: Generate styling instructions
    styling_data = generate_slide_styling_instructions(topic, gemini_client)
    if not styling_data:
        logging.warning("Failed to generate styling. Will use default styling.")
    
    # Step 3: Create the presentation with content
    presentation_title = f"{PRESENTATION_TITLE_PREFIX}{topic}"
    presentation_id, presentation_url = create_presentation_from_data(
        slide_data, presentation_title, slides_service
    )
    
    if not presentation_id:
        logging.error("Failed to create presentation")
        return None, None
    
    # Step 4: Apply styling to the presentation
    if styling_data:
        styling_success = apply_presentation_styling(
            presentation_id, slides_service, slide_data, styling_data
        )
        if styling_success:
            logging.info("Successfully applied custom styling to presentation")
        else:
            logging.warning("Some issues occurred when applying styling")
            
    # call to optimize layout
    optimize_success = optimize_text_layout(presentation_id, slides_service)
    if optimize_success:
        logging.info("Successfully optimized text layout in presentation")
    else:
        logging.warning("Some issues occurred when optimizing text layout")
        
    # Bold
    prefix_formatting_success = apply_bold_to_bullet_prefixes(presentation_id, slides_service)
    if prefix_formatting_success:
        logging.info("Successfully formatted bullet point prefixes in presentation")
    else:
        logging.warning("Some issues occurred when formatting bullet prefixes")
    
    # Step 5: Add shapes with text to slides
    shapes_success = add_shapes_with_text_to_slides(
        presentation_id, slides_service, topic, gemini_client
    )
    if shapes_success:
        logging.info("Successfully added shapes with text to presentation")
    else:
        logging.warning("Some issues occurred when adding shapes")
    
    return presentation_id, presentation_url

# --- Main Execution ---
if __name__ == '__main__':
    try:
        if GEMINI_API_KEY == "YOUR_GEMINI_API_KEY" or not GEMINI_API_KEY: raise ValueError("API key missing")
        if not os.path.exists(CREDENTIALS_FILE): raise FileNotFoundError(f"Creds file missing: {CREDENTIALS_FILE}")
        if not os.path.exists(INPUT_TOPIC_FILE): raise FileNotFoundError(f"Topic file missing: {INPUT_TOPIC_FILE}")
        with open(INPUT_TOPIC_FILE, 'r', encoding='utf-8') as f: topic = f.read().strip()
        if not topic: raise ValueError(f"Topic file empty: {INPUT_TOPIC_FILE}")

        logging.info("Initializing Gemini client..."); gemini_client = genai.Client(api_key=GEMINI_API_KEY)
        logging.info("Gemini client initialized.")
        logging.info("Initializing Google Slides service..."); google_creds = get_google_slides_credentials()
        slides_service = build('slides', 'v1', credentials=google_creds, cache_discovery=False)
        logging.info("Google Slides service initialized.")

        # Create a presentation with content and styling
        presentation_id, presentation_url = create_themed_presentation(topic, gemini_client, slides_service)

        # Report results
        logging.info(f"\n--- Presentation Creation Summary ---")
        final_status = "Unknown Error"
        if presentation_id and presentation_url:
            if "Errors occurred" in presentation_url: final_status = "Partial Success / Errors Occurred"
            elif "Error processing first slide" in presentation_url: final_status = "Partial Success / Error Processing First Slide"
            elif "Error getting" in presentation_url: final_status = "Partial Success / Error Getting Info"
            else: final_status = "Success"
        elif presentation_id: final_status = "Failed During Update (Check Logs)"
        else: final_status = "Failed (Presentation shell not created)"
        logging.info(f"Status: {final_status}"); logging.info(f"Presentation ID: {presentation_id or 'N/A'}")
        logging.info(f"Link: {presentation_url or 'N/A'}"); logging.info("------------------------------------")
        if final_status != "Success": logging.warning("Presentation may be incomplete. Check logs.")

    except FileNotFoundError as e: logging.error(f"Setup Error: {e}")
    except ValueError as e: logging.error(f"Config Error: {e}")
    except HttpError as e:
        error_content = "N/A";
        try:
            if hasattr(e, 'content') and e.content:
                error_content = e.content.decode('utf-8')
        except Exception:
            error_content = str(e.content) # Fallback
        logging.error(f"A Google API error occurred: Status={e.resp.status}, Reason={e.resp.reason}, Content={error_content}")
    except Exception as e:
        logging.error(f"Unexpected Error: {e}", exc_info=True)
